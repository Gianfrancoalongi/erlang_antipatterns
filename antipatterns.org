#+MACRO: REFAC Martin Fowler 1999
#+MACRO: CLEANCODE Robert C. Martin 2009
#+MACRO: PARTIAL Partial Application, Wikipedia
#+MACRO: MONAD Monad, Haskell Wiki
#+MACRO: THECLEANCODER Robert C.Martin 2011
#+OPTIONS: ^:{}

* Introduction

This is a collection of some common anti-patterns I have seen during my career
and daily work. The problematic patterns I describe do not contribute 
to maintainability or readability, they detereorate the quality of the code 
from a maintainability aspect and will further increase the Read / Write ratio
which tends to be substantial for any large system. I believe firmly in the
pragmatic 3-princple

1. Make it work
2. Make it pretty
3. If you need to - optimize it

People tend to forget this in states of stress and pressure. But deviating from your
good practices will not make it easier to work with the code. Anyone can write code 
that the compiler will understand - the hardest part of the craft, which is where the
true mastery comes into play - is to make it self evident and understandable for humans.
* Variable Binding Ad Nauseum (VBAN)
Repeated variable binding of the same variable with varying names 
is the anti-pattern where one base-variable is bound e.g Name, then 
two or more variables are bound with similar names or incremental 
names e.g Name2, NewName. This is an error-prone programming style, 
as someone might use Name3 when they ought to use Name4 or return 
NewName when they should have returned NewName2. It is also an example 
of code duplication ({{{REFAC()}}}).
** Example of VBAN
#+BEGIN_EXAMPLE
f(OldA) ->
 A = g(OldA),
 A2 = h(A),
 NewA = i(A2),
 j(NewA).
#+END_EXAMPLE
** Cause of anti-pattern
Functional languages which have variable binding, like Haskell and Erlang will
not allow you to rebind that variable. This is a result of the lambda calculus
heritage which many functional languages stem from.
In an imperative language, this would be a matter or variable re-assignment.
** Abstraction
As the variables are threaded and used through several calls to functions,
a pattern emerges; it becomes evident that we are 'threading' a state from 
function call to function call.

#+BEGIN_EXAMPLE
   V_i = f_(i-1) ... f_0 V_0
#+END_EXAMPLE

If we rewrite the first example by collapsing the threading in multiple steps

#+BEGIN_EXAMPLE
%% STEP 1 --------------------------
f(OldA) ->            
 A = g(OldA),      
 A2 = h(A),
 NewA = i(A2),
 j(NewA).

%% STEP 2 --------------------------
f(OldA) ->
 A = g(OldA),
 A2 = h(A),
 j(i(A2)).

%% STEP3 ---------------------------
f(OldA) ->   
 A = g(OldA),
 j(i(h(A))). 

%% STEP4 ---------------------------
 f(OldA) ->
  j(i(h(g(OldA)))).
#+END_EXAMPLE

using a cleaner composition notation this is now the same as 

#+BEGIN_EXAMPLE
f(OldA) ->
 j i h g OldA.
#+END_EXAMPLE

** As part of argument chain

It is seldom so easy as in the given example.
The threaded and updated value is often part of a parameter list.
Erlang has regretfully not partial function application ({{{PARTIAL()}}})
and we have to think harder in order to successfully apply this pattern.

Assume this is the case instead

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 {A,D} = g(OldA,B),
 {A2,E} = h(A,B,C,D),
 j(A2,E).
#+END_EXAMPLE

We would like to lend something akin to a sequencing operator from the Haskell
monad concept ({{{MONAD()}}}). Something that takes the result from a computation 
and "threads" it into the next. One of the first easy things to do is to notice 
that both results from g/2 and h/3 are passed onto the next function in the chain, 
thus we restructure the arguments for this.

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 R1 = g(OldA,B)
 R2 = h(R1,B,C),
 j(R2).
#+END_EXAMPLE

Next, remove the unnecessary temporary variable bindings 

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 j(h(g(OldA,B),B,C))
#+END_EXAMPLE

there are still some values blocking us from tightening the parentheses to the right ",B,C))"
how can we get rid of this? Apparently, they are needed to compute the result.

#+BEGIN_EXAMPLE
 OldA----
         \ 
 B------- g/2 ---h/3----j/1
  \_____________/|
                 |
 C---------------
#+END_EXAMPLE

So, what if we always pass all the arguments in a Sequence Scope (SS), as well as the 
previous result? We would then use a sequencer (seq/2), which binds together the output
and input.

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 SS = [OldA,B,C],
 seq([fun([Ax,Bx,Cx]) -> g(Ax,Bx) end,
      fun([Ax,Bx,Cx]) -> h(Ax,Bx,Cx) end,
      fun([Ax|_])     -> j(Ax) end
     ],
     SS).
#+END_EXAMPLE

The key part of this seq/2 function is that it is implicit that the input argument is the 
first element in the list, and this is always replaced by the result of the previous 
function application.

Next,it is a bit annoying that we need to do this fun/1 encapsulation. 
Would it not be nicer if we just wrote something like

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 SS = [OldA,B,C],
 seq([fun g/1,
      fun h/1,
      fun j/1],
     SS).
#+END_EXAMPLE

Yes we can, just wrap the functions with a new function using the same name
and the new signature. the sequencer function seq would be defined as

#+BEGIN_EXAMPLE
seq([],[Result|_]) -> Result;
seq([F|T],[_|T]=SS) ->
 seq(T,[F(SS)|T]).
#+END_EXAMPLE

There is a lot to gain in using this 'sequence style'. The sequence style allows for very
clear and descriptive code composed of small atomic functions operating on a uniform data-structure.

Like this example

#+BEGIN_EXAMPLE
start() -> 
    Steps = [fun set_log_path_and_reset_log_file/0,
             fun log_start_of_service/0,
             fun open_listening_socket/0,
             fun accept_incoming_connection/1,
             fun send_slim_protocol_version/1,
             fun receive_commands_and_send_replies_until_bye/1,
             fun close_connections/1,
             fun log_end_of_service/0,
             fun exit_with_code_zero/0
            ],
    seq:run_(Steps).
#+END_EXAMPLE

\newpage

* Unnecessary Record Expansion (URE)

Pattern matching the values out of a record by record expansion
is a quick way to get what you want. But it also causes a lot of noice
and increases the amount of code the eyes need to travel to get into 
the important bits. This contributes to the bad code smell  
'Vertical Separation' ({{{CLEANCODE()}}}). Additionally, a record expansion 
does not reveal any intent, it is just a method of accessing values for a later portion 
of the code.

Sometimes it is done in the function head, and sometimes immediately after.

** Example of URE in function head
#+BEGIN_EXAMPLE
f(#r{a = Connection_Pool, 
    b = Connection_Id,
    c = #d{a = Msg_Queue},
    f = Black_List} ->
 g(Connection_Pool,
   Connection_Id,
   Msg_Queue,
   Black_List).
#+END_EXAMPLE

** Example of URE in function body
#+BEGIN_EXAMPLE
f(R) ->
 #r{a = Connection_Pool, 
    b = Connection_Id,
    c = #d{a = Msg_Queue},
    f = Black_List} = R,
 g(Connection_Pool,
   Connection_Id,
   Msg_Queue,
   Black_List).
#+END_EXAMPLE
** Cause of anti-pattern

The root of the problem is that we wish to utililize a subset of the available data 
in our system and try to avoid passing a data-container to all parts of the code. 
If the language would be strong enough to allow partial data selection using a lightweight
notation, this would not have been a problem.

** Solution

What if we act lazily, accessing the record fields as we need them?

#+BEGIN_EXAMPLE
f(R) ->
 g(R#r.a,R#r.b,(R#r.c)#d.a,R#r.f).
#+END_EXAMPLE

Notice that your eyes need to travel a much shorter distance,
and you don't need to 'context switch' so gravely to maintain
the context with the immediate relations of surrounding variables.
As we do not occupy so much space per line now, we can easily take
the cost of having more elaborate field names without risking
to march to far of the screen to the right.

#+BEGIN_EXAMPLE
f(R) ->
 g(R#r.connection_pool,
   R#r.connection_id,
   (R#r)#d.msg_queue,
   R#r.black_list
   ).
#+END_EXAMPLE

However, there is now code duplication in the accessing portion of the 
record fields. We have to type, and read 'R#r.' 4 times. 

The best solution is to adress the root cause of the problem, the partial
data access and do so while revealing intent through a specific data subset
extraction function and hide the Record type #r\{\} and #d\{\}.

#+BEGIN_EXAMPLE
f(R) ->
 UCI = get_user_connection_info(R),
 g(UCI).
#+END_EXAMPLE

which can be simplified into 

#+BEGIN_EXAMPLE
f(R) ->
 g(get_user_connection_info(R)).
#+END_EXAMPLE

\newpage

* Unnecessary Term Expansion (UTE)

Unnecessary Term Expansions is the general cousin of URE, where function heads are made unreadable 
by term expansion on any non-branching arguments in the function head.

Thus, any term expansion which is not needed to branch on different function clauses contributes to 
polluting the function head, making it hard for the developers to see which branches are taken in 
what cases.

** Example of UTE

#+BEGIN_EXAMPLE
f(#r{a = A,
     b = [#s{a = [B|_], 
             b = {C,D}=E} | _ ],
     c = #t{a = [F|_],
            b = G,
            c = H}
     d = [I,J,K]},
   G) ->
  % code here
#+END_EXAMPLE

Every time I encounter code like this, I always wonder which of the expanded terms causes the 
function clause to match. All of them? None? Bad news seldom come alone, and it is not uncommon to 
see 6 or 7 function clauses looking similar with many terms expanded. As with URE, this kind of 
unnecessary expansions does not contribute to describe the intent with the code.

** Cause of anti-pattern
Pattern matching makes our lives easier, and it is a very strong feature of many functional programming languages. 
Regrettfully it is easy to abuse, and this happens often when people get eager to 'just get it working'.

** Solution

Avoid expanding terms in the function head, unless the pattern matching is really
needed to select the right function clause. A simple rule like this, could transform the 
example into something as easy as

#+BEGIN_EXAMPLE
f(#r{}=R,G) ->
  % code here
#+END_EXAMPLE

this directly demonstrates, that the important bit here is only that R is
a record of type #r\{\} and nothing else. Likewise, if you really need to branch
on something deeply nested, like the fact that there was an element in the 
list of the field a in the record #t\{\} in the field c of the record #r\{\}, I would
recommend using a macro - and giving the macro a name that conveys intent.

\newpage

* Sprinkling of Coherent Branching Logic (SCBL)

Coherent Branching Logic (CBL) are all program flow control statements which cause branching in the code 
based on inspection of the logically same entity. It becomes sprinkled when all this program flow control is not
coherently placed in the same place, but sprinkled all over the code in different places. 
This is a brother of the named bad code smell 'Shotgun Surgery' ({{{REFAC()}}}).

** Example of SCBL

In the following example, a message is to be sent out to a terminal,
and stored in a database for security reasons (non-repudiation).

#+BEGIN_EXAMPLE
process_message(Message) ->
 send_to_terminal(Message),
 store_in_database(Message),
 ok.

send_to_terminal(Message) ->
 Port = Message#msg.to_port,
 IP = Mesage#msg.to_ip,
 case Message#msg.payload of
  [] -> ignore;
  Text -> 
    terminal_controller:send_to(Port,IP,Text)
 end.

store_in_database(Message) ->
 RefNum = Message#.ref,
 case Message#msg.payload of
  [] -> ignore;
  Text -> 
    db:store_for_reference(RefNum,Text)
 end.
#+END_EXAMPLE

In this case, the same logical entity Message#msg.payload is used for flow
control in two different places. This is sprinkling of CBL.

** Cause of anti-pattern

Working with large systems can cause fear of changing structure or flexing the code base. 
This can be caused by lack of Unit Tests to ensure integrity after restructuring or by lack of confidence. 
'If you want your code to be flexible - you have to flex it!' ({{{THECLEANCODER()}}}).

Thus, when causing a change in the code base, it is often easier to contain the changes in small increments 
'only where needed'. Unfortunately, this is the wrong thing to do as the end system in such a methodology 
will be a patchwork monster of a thousand grouped and unrelated flow control blocks.

** Solution

A better way to write it would have been to branch as early as possible on 
the control variable in question (Message#msg.payload) and restructure any
needed logic.

#+BEGIN_EXAMPLE
process_message(Msg) when Msg#msg.payload == [] ->  
 ok;
process_message(Msg) ->
 send_to_terminal(Msg),
 store_in_database(Msg),
 ok.

send_to_terminal(Message) ->
 Port = Message#msg.to_port,
 IP = Mesage#msg.to_ip,
 Text = Message#msg.payload,
 terminal_controller:send_to(Port,IP,Text).

store_in_database(Message) ->
 RefNum = Message#.ref,
 Text = Message#msg.payload,
 db:store_for_reference(RefNum,Text).
#+END_EXAMPLE

Further, we could abstract the payload type if we want to and make sure it's either undefined or a 
structure of any kind. This way we may at any time change the internal representation of the payload, 
we say that the payload implementation is transparent as we can change it at any time.

#+BEGIN_EXAMPLE
process_message(#msg{payload = ?NONE}) -> ok;
process_message(Message) ->
 send_to_terminal(Message),
 store_in_database(Message),
 ok.

send_to_terminal(Msg) ->
 terminal_controller:send_to(Msg#msg.to_port,
                             Msg#msg.to_ip,
                             Msg#msg.payload).

store_in_database(Msg) ->
 db:store_for_reference(Msg#msg.reference_number,
                        Msg#msg.payload).
#+END_EXAMPLE

The structural diagram for this can be seen below 
(legend FCL(X) for Flow Control Logic on X) and (.) for program flow paths.

#+BEGIN_EXAMPLE
 module a.erl         localizing all 
 with SCBL            CBL in a.erl
 ___________           ____________
| .....      |        |......      | 
|     .      |        |     .      |
| ..FCL(X).  |        |  FCL(X)..  |
| .       .  |        |  .      .  |
| .       .  |        |  .      .  |
| .........  |        |  ........  |
|     .      |        |     .    __|
|     .      |        |     .   | /
|     .      |        |_________|/
| ..FCL(X).  |
| .       .  |
| .       .  |
| .........  |
|     .    __|
|     .   | / 
|_________|/  
#+END_EXAMPLE


\newpage

* Polyaric functions (PF)

It is a good desing rule to keep the amount of arguments to a minimum, not only for readability, 
but also for maintenance reasons. Functions with too many arguments is a bad code smell 'Long Parameter List' ({{{REFAC()}}}).
You will find very few (almost none!) functions in any language standard distribution that require more than three
arguments.

Good design mandates few arguments, try to keep your functions monadic (one argument), dyadic (two arguments), and in worst case triadic (three).
({{{CLEANCODE()}}}).

** Example of PF

#+BEGIN_EXAMPLE
set_up_user_connection(A,B,C,D,E,F,G,H) ->
 %code.
#+END_EXAMPLE

Later used in the code as

#+BEGIN_EXAMPLE
 set_up_user_connection(R#rec.a,
                        BlackListed,
                        Codec,
                        UserList,
                        true,
                        ?T1, 
                        DcData,
                        OARec)

#+END_EXAMPLE

** Cause of anti-pattern

I imagine the thinking goes something like this: "There was a function there, doing what I wanted, almost. 
So, I'll just tag along this extra data, and add another case/if clause." - this is again an example 
of 'Shotgun Surgery' ({{{REFAC()}}}).

** Solution

Data that has coherence and used as one is better to pass as one, this way you do not need
to change the arity of ALL functions which the data has to pass through. The next time this 
package is given another unit of data, you can save yourself and everyone else the 
time of changing all the function calls where the new explicit argument is needed. 
In object orientation there is a refactoring to deal with this, called 'Introduce Parameter Object' ({{{REFAC()}}}).

There are two good ways to do this, we can use records, or proplists.

*** The record approach

Define a private record with an intention-revealing name

#+BEGIN_EXAMPLE
-record(#user_conection_conf,
         {user_name,
          blacklisted_contacts,
          negotiated_codec,
          friends_list,
          has_lte_support,
          connection_side,
          global_dcdata,
          global_oarec}).
#+END_EXAMPLE

*** The proplist approach

An alternative approach is to pass on a proplist, thus adding the intent
for each argument explicitly in the Key part of the KV pair.

#+BEGIN_EXAMPLE
 [{user_name,R#rec.a},
  {blacklisted_contacts,BlackListed},
  {negotiated_codec, Codec},
  {friends_list, UserList},
  {has_lte_support,true},
  {connection_side,?T1},
  {global_dcdata,DcData},
  {global_oarec,ObaRec}
 ].
#+END_EXAMPLE

This way we avoid the same problem of having to add extra arguments to all functions.
Of course, the difference here is that access time will be slower in comparison to using a record.
On the upside, you can change the amount of parameters passed internally without disturbing records
in datbases during upgrade.
\newpage

* Excessive feature disclosure (EFD)

Excessive feature disclosure is a mix of the bad code smells 'Long Method' ({{{REFAC()}}}), 
'Shotgun Surgery' ({{{REFAC()}}}), 'Inappropriate Intimacy' ({{{REFAC()}}}) and 'Mixing 
Levels Of Abstraction' ({{{CLEANCODE()}}}).

Manifested through huge functions with exuberant amounts of case/if statements, 
predicates and equal amounts of incoherent code manipulating small parts of data.
Sometimes the mysterious blocks are commented, and sometimes not. An analogy of such a 
function is a recipe which varies wildly paragraph by paragraph, mentioning 2 spoons of sugar, 
then delving into specific Amperes in stove conduits. Only to end with mind boggling thermodynamics
on the topic of hot-air swirl patterns and the effect on crust forming.

In essence, feature specific mainpulations are visible at the same level of abstraction
as more generic code. It is not abstracted or hidden where necessary.

** Example of EFD
   
#+BEGIN_EXAMPLE
process_message(Message,C) ->
 ok = ensure_there_is_a_free_channel(C),
 ok = ensure_the_db_has_a_free_slot(C),
 %% message reversal feature
 Msg1 = case C#conf.reversal_turned_on of
          true -> lists:reverse(Message);
          false -> Message
        end,
 %% message truncation feature
 Msg2 = case C#conf.truncation_turned_on of
          true -> element(1,
                     lists:foldr(
                       fun(_,{Acc,1}) -> {Acc,0};
                          (C,{Acc,0}) -> {[C|Acc],1}
                       end,
                       {[],0},
                       Msg1));
          false -> Msg1
         end,
  send_message_to_recipient(Msg2),
  db:store_msg_with_ref(Msg2,C).
#+END_EXAMPLE

** Cause of anti-pattern

The mindset of getting it done quick and dirty is the basis for the emergence of this pattern. Small increments of 
code with precise predicate-pinballing will trigger the wanted code, while leaving the 
rest untouched. Locally it is okay, but taking a step back - it becomes obvious that the surrounding context of 
the increment is polluted. Reading such functions top top down is a true feat of mental parcour where each block 
has no relation to the previous, and the whole thing makes no direct sense.
 
** Solution

A general good guideline from Software Craftsmanship is, when you feel something warants a comment to truly 
express your intent: put it in a function. In object orientation we find the refactoring 'Extract Method' ({{{REFAC()}}})
for just this purpose. Put the code into a function, and give it a name which discloses the intent.

#+BEGIN_EXAMPLE
process_message(Message,C) ->
 ok = ensure_there_is_a_free_channel(C),
 ok = ensure_the_db_has_a_free_slot(C),
 Msg1 = feature:possibly_reverse(Message,C),
 Msg2 = feature:possibly_truncate(Msg1,C),
 send_message_to_recipient(Msg2),
 db:store_msg_with_ref(Msg2,C).
#+END_EXAMPLE

Then we can try to reduce the amount of variable bindings as well

#+BEGIN_EXAMPLE
process_message(OldMessage,C) ->
 ok = ensure_there_is_a_free_channel(C),
 ok = ensure_the_db_has_a_free_slot(C),
 SS = [OldMessage,C],
 NewMsg = seq([fun feature:possibly_reverse/1,
               fun feature:possibly_truncate/1
              ],SS),
 send_message_to_recipient(NewMsg),
 db:store_msg_with_ref(Msg2,C).
#+END_EXAMPLE

Adding yet two, three, or five new features that each one manipulate the message is just new hooks into the 
sequencing. However, the main point is the abstraction that now makes it easy to understand the main flow.

\newpage

* Mixing Pure and Side Effecting Code (MPSEC)
Mixing functionally pure and side effecting code is a common
and unfortunate antipattern as it makes the code hard to test
and difficult to abstract.

#+BEGIN_EXAMPLE
  _______________
 |.......o....o..|
 |..oo...o..o....|
 |.......o....o..|
 |.....o......o..|
 |..o.o..ooo.....|
 |....o.o....o.o.|
  ---------------

  o = impurity    
  . = pure code
#+END_EXAMPLE

Impure functions are usually related to reading/writing configuration data and 
sending/receiving messages. It is not uncommon for such impurity to cluster in areas
related to gate logic (testing for certain conditions to hold, such as input validation.

It is better to localise side-effecting (impure) code to a few places in the code, 
or to push the impure code out to the fringes of the system.

** Cause of anti-pattern

Lack of TDD will allow hard to test code to grow in your repository.

** Solution

Develop using TDD. Doing TDD will force you to decompose single operations as
functions handling one part of the functionality: automatically separating the
impurity from the purity.

The outcome from such a design is a collection of pure libraries, which are utilized by a 
few impure modules - essentially 'orchestrating' the flow. All of the pure libraries can be Unit tested 
easily, while the few orchestrators can be tested using Component Tests. Mocking will also be easier as 
the code is well contained in pure library functions.

*** A system where impurity is pushed towards the fringes

#+BEGIN_EXAMPLE
  _______________
 |             |I|
 |  SYSTEM     |M|
 |  COMPOSED   |P|
 |  OF PURE    |U|
 |  FUNCTIONS  |R|
 |             |E|
 |_____________|_|

   ^            ^
   |            |
   |             \ More difficult to test
   |              
    \ Easy to Unit Test = Write with TDD

#+END_EXAMPLE

*** A system where impurity is clustered into a few points

#+BEGIN_EXAMPLE
  _______________
 |...............|
 |..oo...........|
 |..oo.......oo..|
 |...........oo..|
 |...............|
 |...............|
  ---------------

  o = impurity    
  . = pure code
#+END_EXAMPLE

\newpage
* Implicit Branch Condition Encoded In Primitives (IBCEIP)

Implicit Branch Conditin Encoded In Primitives is coupled to the bad code smell Primitive Obsession where
primitive data types are used to represent domain ideas ({{{CLEANCODE()}}}). The difference is that in 
IBCEIP, the branching reason is hidden and not made explicit with the help of the language.

This makes for very hard to read code that can not be understood unless you have the full context
and history of the program being developed in order to understand why certain primitives are patternmatched.

** Example of IBCEIP

Consider the following code that handles session restore on a system failure, in this particular case we will 
look at how the different backup_session function clauses are chosen based on the user being behind nat or not.

#+BEGIN_EXAMPLE
backup_session(#user{ctd=#conn{ip=A,port=B},
                     last_msg=[#msg{trp=#conn{orig_ip_text=C}}|_]}) 
                     when A =/= C ->
  %% This is NAT because the last seen message from the user has an 
  %% originates ip text from another IP address than the user connected from. 
  %% 
   ....
backup_session(User) ->
   %% normal case
   ....
#+END_EXAMPLE

Notice how the comment is used to tell us why this is a special case, this is a typical example of how
comments are a deodorant - hiding a bad code smell. But we know that comments will rot and start to lie
about reality when people update the code but does not update the comments.

** Solution

Add a function that takes a #user\{\} record and returns an appropriate representation of the branch condition.
Use this value instead when patternmatching, put the value in the record, or pass it to the backup_session/1
function, making it take 2 arguments instead.

#+BEGIN_EXAMPLE
determine_connectivity_mode(User) ->
   #user{ctd=#conn{ip=A},last_msg=[#msg{trp=#conn{orig_ip_text=C}}|_]}) = User,
   case A == C of  
    true  -> normal;
    false -> behind_nat.

backup_session(User,behind_nat) ->
   ...;
backup_session(User,normal) ->
   ....
#+END_EXAMPLE

Notice how the backup_session/2 code conveys intent in a much better way.
The determine_connectivity_mode/1 function is also very easy to test and would be a perfect
candidate function for TDD.


* Not an Antipattern - (Seq)uence And (Rec)ursive style 
 
In the chapter Variable Binding ad Nauseum, we touched on the subject of seq style programming.
This chapter explores the seq concept further and also defines rec, a cousin of seq that allows
for an elegant recursive programming style. 

** Seq
Seq takes a list of functions, some initial data

#+BEGIN_EXAMPLE
 Seq :: [F] x D -> D
#+END_EXAMPLE

and it folds the functions over the data, effectively applying each and every function on the input 
from the previous function; for the initial function this means the initial data, as there is no other 
function that can be called to produce the data.

#+BEGIN_EXAMPLE
 D_0 = Input data
 D_1 = f_1(D_0)
 D_2 = f_2(D_1)
 ...           
 D_n = f_n(D_(n-1))
#+END_EXAMPLE


*** Function families

Every function F which is passed to Seq can be classified as beloning to one of three function families f_p, f_m or f_n.

**** f_p - Pure family 
This is a functionally pure function, the return value is used to update the input data to Seq on which we fold our
functions. The only reason for using this function is for the pure calculation done with the use of the input data that
is sent to it.

#+BEGIN_EXAMPLE
f(X) ->
   X + 1.
#+END_EXAMPLE

**** f_m - Mixed family
This is an functionally impure family of functions, meaning that they have side effects, but the returned 
value is still of interest for the next function in seq. As this has a side-effect, we can think of this family
of functions as updating an implicit global state (omega). 

#+BEGIN_EXAMPLE
f(X) ->
  a ! X,
  X + 1.
#+END_EXAMPLE

**** f_n - Nullifier family
This is a family of functions which has an unused return value, meaning we do not care about the return value of the
function. The function is only invoked due to the side effects of the function. Thus, the result is nullified in the 
eyes of the next function to be invoked in the seq chain.

#+BEGIN_EXAMPLE
f(X) ->
  a ! X.
#+END_EXAMPLE













*** Function class family diagram 

All families relate to the Seq input data D and the global state Omega in some way.
In the diagram below, an arrow from D -> to a family means that this family uses the data D for its calculation.
An arrow from a family f_m -> to either D or Omega means that this family has a return value that updates the 
data in D or Omega.

#+BEGIN_EXAMPLE

   D <--------\     Omega
   |          |       ^
   |--> f_p --|       |
   |          |       |
   |--> f_m --/-------|
   |                  |
   \--> f_n-----------/

#+END_EXAMPLE
