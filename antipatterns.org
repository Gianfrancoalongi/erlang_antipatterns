#+MACRO: REFAC Martin Fowler 1999
#+MACRO: CLEANCODE Robert C. Martin 2009
#+MACRO: PARTIAL Partial Application, Wikipedia
#+MACRO: MONAD Monad, Haskell Wiki
#+MACRO: THECLEANCODER Robert C.Martin 2011
#+OPTIONS: ^:{}

* Introduction

This is a collection of some common anti-patterns I have seen during my career
and daily work. The problematic patterns I describe do not contribute 
to maintainability or readability, they detereorate the quality of the code 
from a maintainability aspect and will further increase the Read / Write ratio
which tends to be substantial for any large system. I believe firmly in the
pragmatic 3-princple

1. Make it work
2. Make it pretty
3. If you need to - optimize it

People tend to forget this in states of stress and pressure. But deviating from your
good practices will not make it easier to work with the code. Anyone can write code 
that the compiler will understand - the hardest part of the craft, which is where the
true mastery comes into play - is to make it self evident and understandable for humans.
* Variable Binding Ad Nauseum (VBAN)
Repeated variable binding of the same variable with varying names 
is the anti-pattern where one base-variable is bound e.g Name, then 
two or more variables are bound with similar names or incremental 
names e.g Name2, NewName. This is an error-prone programming style, 
as someone might use Name3 when they ought to use Name4 or return 
NewName when they should have returned NewName2. It is also an example 
of code duplication ({{{REFAC()}}}).
** Example of VBAN
#+BEGIN_EXAMPLE
f(OldA) ->
 A = g(OldA),
 A2 = h(A),
 NewA = i(A2),
 j(NewA).
#+END_EXAMPLE
** Cause of anti-pattern
Functional languages which have variable binding, like Haskell and Erlang will
not allow you to rebind that variable. This is a result of the lambda calculus
heritage which many functional languages stem from.
In an imperative language, this would be a matter or variable re-assignment.
** Abstraction
As the variables are threaded and used through several calls to functions,
a pattern emerges; it becomes evident that we are 'threading' a state from 
function call to function call.

#+BEGIN_EXAMPLE
   V_i = f_(i-1) ... f_0 V_0
#+END_EXAMPLE

If we rewrite the first example by collapsing the threading in multiple steps

#+BEGIN_EXAMPLE
%% STEP 1 --------------------------
f(OldA) ->            
 A = g(OldA),      
 A2 = h(A),
 NewA = i(A2),
 j(NewA).

%% STEP 2 --------------------------
f(OldA) ->
 A = g(OldA),
 A2 = h(A),
 j(i(A2)).

%% STEP3 ---------------------------
f(OldA) ->   
 A = g(OldA),
 j(i(h(A))). 

%% STEP4 ---------------------------
 f(OldA) ->
  j(i(h(g(OldA)))).
#+END_EXAMPLE

using a cleaner composition notation this is now the same as 

#+BEGIN_EXAMPLE
f(OldA) ->
 j i h g OldA.
#+END_EXAMPLE

** As part of argument chain

It is seldom so easy as in the given example.
The threaded and updated value is often part of a parameter list.
Erlang has regretfully not partial function application ({{{PARTIAL()}}})
and we have to think harder in order to successfully apply this pattern.

Assume this is the case instead

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 {A,D} = g(OldA,B),
 {A2,E} = h(A,B,C,D),
 j(A2,E).
#+END_EXAMPLE

We would like to lend something akin to a sequencing operator from the Haskell
monad concept ({{{MONAD()}}}). Something that takes the result from a computation 
and "threads" it into the next. One of the first easy things to do is to notice 
that both results from g/2 and h/3 are passed onto the next function in the chain, 
thus we restructure the arguments for this.

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 R1 = g(OldA,B)
 R2 = h(R1,B,C),
 j(R2).
#+END_EXAMPLE

Next, remove the unnecessary temporary variable bindings 

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 j(h(g(OldA,B),B,C))
#+END_EXAMPLE

there are still some values blocking us from tightening the parentheses to the right ",B,C))"
how can we get rid of this? Apparently, they are needed to compute the result.

#+BEGIN_EXAMPLE
 OldA----
         \ 
 B------- g/2 ---h/3----j/1
  \_____________/|
                 |
 C---------------
#+END_EXAMPLE

So, what if we always pass all the arguments in a Sequence Scope (SS), as well as the 
previous result? We would then use a sequencer (seq/2), which binds together the output
and input.

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 SS = [OldA,B,C],
 seq([fun([Ax,Bx,Cx]) -> g(Ax,Bx) end,
      fun([Ax,Bx,Cx]) -> h(Ax,Bx,Cx) end,
      fun([Ax|_])     -> j(Ax) end
     ],
     SS).
#+END_EXAMPLE

The key part of this seq/2 function is that it is implicit that the input argument is the 
first element in the list, and this is always replaced by the result of the previous 
function application.

Next,it is a bit annoying that we need to do this fun/1 encapsulation. 
Would it not be nicer if we just wrote something like

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 SS = [OldA,B,C],
 seq([fun g/1,
      fun h/1,
      fun j/1],
     SS).
#+END_EXAMPLE

Yes we can, just wrap the functions with a new function using the same name
and the new signature. the sequencer function seq would be defined as

#+BEGIN_EXAMPLE
seq([],[Result|_]) -> Result;
seq([F|T],[_|T]=SS) ->
 seq(T,[F(SS)|T]).
#+END_EXAMPLE

There is a lot to gain in using this 'sequence style'. The sequence style allows for very
clear and descriptive code composed of small atomic functions operating on a uniform data-structure.

Like this example

#+BEGIN_EXAMPLE
start() -> 
    Steps = [fun set_log_path_and_reset_log_file/0,
             fun log_start_of_service/0,
             fun open_listening_socket/0,
             fun accept_incoming_connection/1,
             fun send_slim_protocol_version/1,
             fun receive_commands_and_send_replies_until_bye/1,
             fun close_connections/1,
             fun log_end_of_service/0,
             fun exit_with_code_zero/0
            ],
    seq:run_(Steps).
#+END_EXAMPLE

\newpage

* Unnecessary Record Expansion (URE)

Pattern matching the values out of a record by record expansion
is a quick way to get what you want. But it also causes a lot of noice
and increases the amount of code the eyes need to travel to get into 
the important bits. This contributes to the bad code smell  
'Vertical Separation' ({{{CLEANCODE()}}}). Additionally, a record expansion 
does not reveal any intent, it is just a method of accessing values for a later portion 
of the code.

Sometimes it is done in the function head, and sometimes immediately after.

** Example of URE in function head
#+BEGIN_EXAMPLE
f(#r{a = Connection_Pool, 
    b = Connection_Id,
    c = #d{a = Msg_Queue},
    f = Black_List} ->
 g(Connection_Pool,
   Connection_Id,
   Msg_Queue,
   Black_List).
#+END_EXAMPLE

** Example of URE in function body
#+BEGIN_EXAMPLE
f(R) ->
 #r{a = Connection_Pool, 
    b = Connection_Id,
    c = #d{a = Msg_Queue},
    f = Black_List} = R,
 g(Connection_Pool,
   Connection_Id,
   Msg_Queue,
   Black_List).
#+END_EXAMPLE
** Cause of anti-pattern

The root of the problem is that we wish to utililize a subset of the available data 
in our system and try to avoid passing a data-container to all parts of the code. 
If the language would be strong enough to allow partial data selection using a lightweight
notation, this would not have been a problem.

** Solution

What if we act lazily, accessing the record fields as we need them?

#+BEGIN_EXAMPLE
f(R) ->
 g(R#r.a,R#r.b,(R#r.c)#d.a,R#r.f).
#+END_EXAMPLE

Notice that your eyes need to travel a much shorter distance,
and you don't need to 'context switch' so gravely to maintain
the context with the immediate relations of surrounding variables.
As we do not occupy so much space per line now, we can easily take
the cost of having more elaborate field names without risking
to march to far of the screen to the right.

#+BEGIN_EXAMPLE
f(R) ->
 g(R#r.connection_pool,
   R#r.connection_id,
   (R#r)#d.msg_queue,
   R#r.black_list
   ).
#+END_EXAMPLE

However, there is now code duplication in the accessing portion of the 
record fields. We have to type, and read 'R#r.' 4 times. 

The best solution is to adress the root cause of the problem, the partial
data access and do so while revealing intent through a specific data subset
extraction function and hide the Record type #r\{\} and #d\{\}.

#+BEGIN_EXAMPLE
f(R) ->
 UCI = get_user_connection_info(R),
 g(UCI).
#+END_EXAMPLE

which can be simplified into 

#+BEGIN_EXAMPLE
f(R) ->
 g(get_user_connection_info(R)).
#+END_EXAMPLE

\newpage


* Unnecessary Term Expansion (UTE)

Unnecessary Term Expansions is the general cousin of URE, where function heads are made unreadable 
by term expansion on any non-branching arguments in the function head.

Thus, any term expansion which is not needed to branch on different function clauses contributes to 
polluting the function head, making it hard for the developers to see which branches are taken in 
what cases.

** Example of UTE

#+BEGIN_EXAMPLE
f(#r{a = A,
     b = [#s{a = [B|_], 
             b = {C,D}=E} | _ ],
     c = #t{a = [F|_],
            b = G,
            c = H}
     d = [I,J,K]},
   G) ->
  % code here
#+END_EXAMPLE

Every time I encounter code like this, I always wonder which of the expanded terms causes the 
function clause to match. All of them? None? Bad news seldom come alone, and it is not uncommon to 
see 6 or 7 function clauses looking similar with many terms expanded. As with URE, this kind of 
unnecessary expansions does not contribute to describe the intent with the code.

** Cause of anti-pattern
Pattern matching makes our lives easier, and it is a very strong feature of many functional programming languages. 
Regrettfully it is easy to abuse, and this happens often when people get eager to 'just get it working'.

** Solution

Avoid expanding terms in the function head, unless the pattern matching is really
needed to select the right function clause. A simple rule like this, could transform the 
example into something as easy as

#+BEGIN_EXAMPLE
f(#r{}=R,G) ->
  % code here
#+END_EXAMPLE

this directly demonstrates, that the important bit here is only that R is
a record of type #r\{\} and nothing else. Likewise, if you really need to branch
on something deeply nested, like the fact that there was an element in the 
list of the field a in the record #t\{\} in the field c of the record #r\{\}, I would
recommend using a macro - and giving the macro a name that conveys intent.

\newpage

* Sprinkling of Coherent Branching Logic (SCBL)

Coherent Branching Logic (CBL) are all program flow control statements which cause branching in the code 
based on inspection of the logically same entity. It becomes sprinkled when all this program flow control is not
coherently placed in the same place, but sprinkled all over the code in different places. 
This is a brother of the named bad code smell 'Shotgun Surgery' ({{{REFAC()}}}).

** Example of SCBL

In the following example, a message is to be sent out to a terminal,
and stored in a database for security reasons (non-repudiation).

#+BEGIN_EXAMPLE
process_message(Message) ->
 send_to_terminal(Message),
 store_in_database(Message),
 ok.

send_to_terminal(Message) ->
 Port = Message#msg.to_port,
 IP = Mesage#msg.to_ip,
 case Message#msg.payload of
  [] -> ignore;
  Text -> 
    terminal_controller:send_to(Port,IP,Text)
 end.

store_in_database(Message) ->
 RefNum = Message#.ref,
 case Message#msg.payload of
  [] -> ignore;
  Text -> 
    db:store_for_reference(RefNum,Text)
 end.
#+END_EXAMPLE

In this case, the same logical entity Message#msg.payload is used for flow
control in two different places. This is sprinkling of CBL.

** Cause of anti-pattern

Working with large systems can cause fear of changing structure or flexing the code base. 
This can be caused by lack of Unit Tests to ensure integrity after restructuring or by lack of confidence. 
'If you want your code to be flexible - you have to flex it!' ({{{THECLEANCODER()}}}).

Thus, when causing a change in the code base, it is often easier to contain the changes in small increments 
'only where needed'. Unfortunately, this is the wrong thing to do as the end system in such a methodology 
will be a patchwork monster of a thousand grouped and unrelated flow control blocks.

** Solution

A better way to write it would have been to branch as early as possible on 
the control variable in question (Message#msg.payload) and restructure any
needed logic.

#+BEGIN_EXAMPLE
process_message(Msg) when Msg#msg.payload == [] ->  
 ok;
process_message(Msg) ->
 send_to_terminal(Msg),
 store_in_database(Msg),
 ok.

send_to_terminal(Message) ->
 Port = Message#msg.to_port,
 IP = Mesage#msg.to_ip,
 Text = Message#msg.payload,
 terminal_controller:send_to(Port,IP,Text).

store_in_database(Message) ->
 RefNum = Message#.ref,
 Text = Message#msg.payload,
 db:store_for_reference(RefNum,Text).
#+END_EXAMPLE

Further, we could abstract the payload type if we want to and make sure it's either undefined or a 
structure of any kind. This way we may at any time change the internal representation of the payload, 
we say that the payload implementation is transparent as we can change it at any time.

#+BEGIN_EXAMPLE
process_message(#msg{payload = ?NONE}) -> ok;
process_message(Message) ->
 send_to_terminal(Message),
 store_in_database(Message),
 ok.

send_to_terminal(Msg) ->
 terminal_controller:send_to(Msg#msg.to_port,
                             Msg#msg.to_ip,
                             Msg#msg.payload).

store_in_database(Msg) ->
 db:store_for_reference(Msg#msg.reference_number,
                        Msg#msg.payload).
#+END_EXAMPLE

The structural diagram for this can be seen below 
(legend FCL(X) for Flow Control Logic on X) and (.) for program flow paths.

#+BEGIN_EXAMPLE
 module a.erl         localizing all 
 with SCBL            CBL in a.erl
 ___________           ____________
| .....      |        |......      | 
|     .      |        |     .      |
| ..FCL(X).  |        |  FCL(X)..  |
| .       .  |        |  .      .  |
| .       .  |        |  .      .  |
| .........  |        |  ........  |
|     .      |        |     .    __|
|     .      |        |     .   | /
|     .      |        |_________|/
| ..FCL(X).  |
| .       .  |
| .       .  |
| .........  |
|     .    __|
|     .   | / 
|_________|/  
#+END_EXAMPLE


\newpage
