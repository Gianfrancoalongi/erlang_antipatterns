#+MACRO: REFAC Martin Fowler 1999
#+MACRO: CLEANCODE Robert C. Martin 2009
#+MACRO: PARTIAL Partial Application, Wikipedia
#+MACRO: MONAD Monad, Haskell Wiki
#+MACRO: THECLEANCODER Robert C.Martin 2011
#+MACRO: LENSES Haskell Wiki
#+OPTIONS: ^:{}

* Introduction

This is a collection of some common anti-patterns I have seen during my career
and daily work. The problematic patterns I describe do not contribute 
to maintainability or readability, they detereorate the quality of the code 
from a maintainability aspect and will further increase the Read / Write ratio
which tends to be substantial for any large system. I believe firmly in the
pragmatic 3-princple

1. Make it work
2. Make it pretty
3. If you need to - optimize it

People tend to forget this in states of stress and pressure. But deviating from your
good practices will not make it easier to work with the code. Anyone can write code 
that the compiler will understand - the hardest part of the craft, which is where the
true mastery comes into play - is to make it self evident and understandable for humans.
* Variable Binding Ad Nauseum (VBAN)
Repeated variable binding of the same variable with varying names 
is the anti-pattern where one base-variable is bound e.g Name, then 
two or more variables are bound with similar names or incremental 
names e.g Name2, NewName. This is an error-prone programming style, 
as someone might use Name3 when they ought to use Name4 or return 
NewName when they should have returned NewName2. It is also an example 
of code duplication ({{{REFAC()}}}).
** Example of VBAN
#+BEGIN_EXAMPLE
f(OldA) ->
 A = g(OldA),
 A2 = h(A),
 NewA = i(A2),
 j(NewA).
#+END_EXAMPLE
** Cause of anti-pattern
Functional languages which have variable binding, like Haskell and Erlang will
not allow you to rebind that variable. This is a result of the lambda calculus
heritage which many functional languages stem from.
In an imperative language, this would be a matter or variable re-assignment.
** Abstraction
As the variables are threaded and used through several calls to functions,
a pattern emerges; it becomes evident that we are 'threading' a state from 
function call to function call.

#+BEGIN_EXAMPLE
   V_i = f_(i-1) ... f_0 V_0
#+END_EXAMPLE

If we rewrite the first example by collapsing the threading in multiple steps

#+BEGIN_EXAMPLE
%% STEP 1 --------------------------
f(OldA) ->            
 A = g(OldA),      
 A2 = h(A),
 NewA = i(A2),
 j(NewA).

%% STEP 2 --------------------------
f(OldA) ->
 A = g(OldA),
 A2 = h(A),
 j(i(A2)).

%% STEP3 ---------------------------
f(OldA) ->   
 A = g(OldA),
 j(i(h(A))). 

%% STEP4 ---------------------------
 f(OldA) ->
  j(i(h(g(OldA)))).
#+END_EXAMPLE

using a cleaner composition notation this is now the same as 

#+BEGIN_EXAMPLE
f(OldA) ->
 j i h g OldA.
#+END_EXAMPLE

** As part of argument chain

It is seldom so easy as in the given example.
The threaded and updated value is often part of a parameter list.
Erlang has regretfully not partial function application ({{{PARTIAL()}}})
and we have to think harder in order to successfully apply this pattern.

Assume this is the case instead

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 {A,D} = g(OldA,B),
 {A2,E} = h(A,B,C,D),
 j(A2,E).
#+END_EXAMPLE

We would like to lend something akin to a sequencing operator from the Haskell
monad concept ({{{MONAD()}}}). Something that takes the result from a computation 
and "threads" it into the next. One of the first easy things to do is to notice 
that both results from g/2 and h/3 are passed onto the next function in the chain, 
thus we restructure the arguments for this.

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 R1 = g(OldA,B)
 R2 = h(R1,B,C),
 j(R2).
#+END_EXAMPLE

Next, remove the unnecessary temporary variable bindings 

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 j(h(g(OldA,B),B,C))
#+END_EXAMPLE

there are still some values blocking us from tightening the parentheses to the right ",B,C))"
how can we get rid of this? Apparently, they are needed to compute the result.

#+BEGIN_EXAMPLE
 OldA----
         \ 
 B------- g/2 ---h/3----j/1
  \_____________/|
                 |
 C---------------
#+END_EXAMPLE

So, what if we always pass all the arguments in a Sequence Scope (SS), as well as the 
previous result? We would then use a sequencer (seq/2), which binds together the output
and input.

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 SS = [OldA,B,C],
 seq([fun([Ax,Bx,Cx]) -> g(Ax,Bx) end,
      fun([Ax,Bx,Cx]) -> h(Ax,Bx,Cx) end,
      fun([Ax|_])     -> j(Ax) end
     ],
     SS).
#+END_EXAMPLE

The key part of this seq/2 function is that it is implicit that the input argument is the 
first element in the list, and this is always replaced by the result of the previous 
function application.

Next,it is a bit annoying that we need to do this fun/1 encapsulation. 
Would it not be nicer if we just wrote something like

#+BEGIN_EXAMPLE
f(OldA,B,C) ->
 SS = [OldA,B,C],
 seq([fun g/1,
      fun h/1,
      fun j/1],
     SS).
#+END_EXAMPLE

Yes we can, just wrap the functions with a new function using the same name
and the new signature. the sequencer function seq would be defined as

#+BEGIN_EXAMPLE
seq([],[Result|_]) -> Result;
seq([F|T],[_|T]=SS) ->
 seq(T,[F(SS)|T]).
#+END_EXAMPLE

There is a lot to gain in using this 'sequence style'. The sequence style allows for very
clear and descriptive code composed of small atomic functions operating on a uniform data-structure.

Like this example

#+BEGIN_EXAMPLE
start() -> 
    Steps = [fun set_log_path_and_reset_log_file/0,
             fun log_start_of_service/0,
             fun open_listening_socket/0,
             fun accept_incoming_connection/1,
             fun send_slim_protocol_version/1,
             fun receive_commands_and_send_replies_until_bye/1,
             fun close_connections/1,
             fun log_end_of_service/0,
             fun exit_with_code_zero/0
            ],
    seq:run_(Steps).
#+END_EXAMPLE

\newpage

* Unnecessary Record Expansion (URE)

Pattern matching the values out of a record by record expansion
is a quick way to get what you want. But it also causes a lot of noice
and increases the amount of code the eyes need to travel to get into 
the important bits. This contributes to the bad code smell  
'Vertical Separation' ({{{CLEANCODE()}}}). Additionally, a record expansion 
does not reveal any intent, it is just a method of accessing values for a later portion 
of the code.

Sometimes it is done in the function head, and sometimes immediately after.

** Example of URE in function head
#+BEGIN_EXAMPLE
f(#r{a = Connection_Pool, 
    b = Connection_Id,
    c = #d{a = Msg_Queue},
    f = Black_List} ->
 g(Connection_Pool,
   Connection_Id,
   Msg_Queue,
   Black_List).
#+END_EXAMPLE

** Example of URE in function body
#+BEGIN_EXAMPLE
f(R) ->
 #r{a = Connection_Pool, 
    b = Connection_Id,
    c = #d{a = Msg_Queue},
    f = Black_List} = R,
 g(Connection_Pool,
   Connection_Id,
   Msg_Queue,
   Black_List).
#+END_EXAMPLE
** Cause of anti-pattern

The root of the problem is that we wish to utililize a subset of the available data 
in our system and try to avoid passing a data-container to all parts of the code. 
If the language would be strong enough to allow partial data selection using a lightweight
notation, this would not have been a problem.

** Solution

What if we act lazily, accessing the record fields as we need them?

#+BEGIN_EXAMPLE
f(R) ->
 g(R#r.a,R#r.b,(R#r.c)#d.a,R#r.f).
#+END_EXAMPLE

Notice that your eyes need to travel a much shorter distance,
and you don't need to 'context switch' so gravely to maintain
the context with the immediate relations of surrounding variables.
As we do not occupy so much space per line now, we can easily take
the cost of having more elaborate field names without risking
to march to far of the screen to the right.

#+BEGIN_EXAMPLE
f(R) ->
 g(R#r.connection_pool,
   R#r.connection_id,
   (R#r)#d.msg_queue,
   R#r.black_list
   ).
#+END_EXAMPLE

However, there is now code duplication in the accessing portion of the 
record fields. We have to type, and read 'R#r.' 4 times. 

The best solution is to adress the root cause of the problem, the partial
data access and do so while revealing intent through a specific data subset
extraction function and hide the Record type #r\{\} and #d\{\}.

#+BEGIN_EXAMPLE
f(R) ->
 UCI = get_user_connection_info(R),
 g(UCI).
#+END_EXAMPLE

which can be simplified into 

#+BEGIN_EXAMPLE
f(R) ->
 g(get_user_connection_info(R)).
#+END_EXAMPLE

\newpage

* Unnecessary Term Expansion (UTE)

Unnecessary Term Expansions is the general cousin of URE, where function heads are made unreadable 
by term expansion on any non-branching arguments in the function head.

Thus, any term expansion which is not needed to branch on different function clauses contributes to 
polluting the function head, making it hard for the developers to see which branches are taken in 
what cases.

** Example of UTE

#+BEGIN_EXAMPLE
f(#r{a = A,
     b = [#s{a = [B|_], 
             b = {C,D}=E} | _ ],
     c = #t{a = [F|_],
            b = G,
            c = H}
     d = [I,J,K]},
   G) ->
  % code here
#+END_EXAMPLE

Every time I encounter code like this, I always wonder which of the expanded terms causes the 
function clause to match. All of them? None? Bad news seldom come alone, and it is not uncommon to 
see 6 or 7 function clauses looking similar with many terms expanded. As with URE, this kind of 
unnecessary expansions does not contribute to describe the intent with the code.

** Cause of anti-pattern
Pattern matching makes our lives easier, and it is a very strong feature of many functional programming languages. 
Regrettfully it is easy to abuse, and this happens often when people get eager to 'just get it working'.

** Solution

Avoid expanding terms in the function head, unless the pattern matching is really
needed to select the right function clause. A simple rule like this, could transform the 
example into something as easy as

#+BEGIN_EXAMPLE
f(#r{}=R,G) ->
  % code here
#+END_EXAMPLE

this directly demonstrates, that the important bit here is only that R is
a record of type #r\{\} and nothing else. Likewise, if you really need to branch
on something deeply nested, like the fact that there was an element in the 
list of the field a in the record #t\{\} in the field c of the record #r\{\}, I would
recommend using a macro - and giving the macro a name that conveys intent.

\newpage

* Sprinkling of Coherent Branching Logic (SCBL)

Coherent Branching Logic (CBL) are all program flow control statements which cause branching in the code 
based on inspection of the logically same entity. It becomes sprinkled when all this program flow control is not
coherently placed in the same place, but sprinkled all over the code in different places. 
This is a brother of the named bad code smell 'Shotgun Surgery' ({{{REFAC()}}}).

** Example of SCBL

In the following example, a message is to be sent out to a terminal,
and stored in a database for security reasons (non-repudiation).

#+BEGIN_EXAMPLE
process_message(Message) ->
 send_to_terminal(Message),
 store_in_database(Message),
 ok.

send_to_terminal(Message) ->
 Port = Message#msg.to_port,
 IP = Mesage#msg.to_ip,
 case Message#msg.payload of
  [] -> ignore;
  Text -> 
    terminal_controller:send_to(Port,IP,Text)
 end.

store_in_database(Message) ->
 RefNum = Message#.ref,
 case Message#msg.payload of
  [] -> ignore;
  Text -> 
    db:store_for_reference(RefNum,Text)
 end.
#+END_EXAMPLE

In this case, the same logical entity Message#msg.payload is used for flow
control in two different places. This is sprinkling of CBL.

** Cause of anti-pattern

Working with large systems can cause fear of changing structure or flexing the code base. 
This can be caused by lack of Unit Tests to ensure integrity after restructuring or by lack of confidence. 
'If you want your code to be flexible - you have to flex it!' ({{{THECLEANCODER()}}}).

Thus, when causing a change in the code base, it is often easier to contain the changes in small increments 
'only where needed'. Unfortunately, this is the wrong thing to do as the end system in such a methodology 
will be a patchwork monster of a thousand grouped and unrelated flow control blocks.

** Solution

A better way to write it would have been to branch as early as possible on 
the control variable in question (Message#msg.payload) and restructure any
needed logic.

#+BEGIN_EXAMPLE
process_message(Msg) when Msg#msg.payload == [] ->  
 ok;
process_message(Msg) ->
 send_to_terminal(Msg),
 store_in_database(Msg),
 ok.

send_to_terminal(Message) ->
 Port = Message#msg.to_port,
 IP = Mesage#msg.to_ip,
 Text = Message#msg.payload,
 terminal_controller:send_to(Port,IP,Text).

store_in_database(Message) ->
 RefNum = Message#.ref,
 Text = Message#msg.payload,
 db:store_for_reference(RefNum,Text).
#+END_EXAMPLE

Further, we could abstract the payload type if we want to and make sure it's either undefined or a 
structure of any kind. This way we may at any time change the internal representation of the payload, 
we say that the payload implementation is transparent as we can change it at any time.

#+BEGIN_EXAMPLE
process_message(#msg{payload = ?NONE}) -> ok;
process_message(Message) ->
 send_to_terminal(Message),
 store_in_database(Message),
 ok.

send_to_terminal(Msg) ->
 terminal_controller:send_to(Msg#msg.to_port,
                             Msg#msg.to_ip,
                             Msg#msg.payload).

store_in_database(Msg) ->
 db:store_for_reference(Msg#msg.reference_number,
                        Msg#msg.payload).
#+END_EXAMPLE

The structural diagram for this can be seen below 
(legend FCL(X) for Flow Control Logic on X) and (.) for program flow paths.

#+BEGIN_EXAMPLE
 module a.erl         localizing all 
 with SCBL            CBL in a.erl
 ___________           ____________
| .....      |        |......      | 
|     .      |        |     .      |
| ..FCL(X).  |        |  FCL(X)..  |
| .       .  |        |  .      .  |
| .       .  |        |  .      .  |
| .........  |        |  ........  |
|     .      |        |     .    __|
|     .      |        |     .   | /
|     .      |        |_________|/
| ..FCL(X).  |
| .       .  |
| .       .  |
| .........  |
|     .    __|
|     .   | / 
|_________|/  
#+END_EXAMPLE


\newpage

* Polyaric functions (PF)

It is a good desing rule to keep the amount of arguments to a minimum, not only for readability, 
but also for maintenance reasons. Functions with too many arguments is a bad code smell 'Long Parameter List' ({{{REFAC()}}}).
You will find very few (almost none!) functions in any language standard distribution that require more than three
arguments.

Good design mandates few arguments, try to keep your functions monadic (one argument), dyadic (two arguments), and in worst case triadic (three).
({{{CLEANCODE()}}}).

** Example of PF

#+BEGIN_EXAMPLE
set_up_user_connection(A,B,C,D,E,F,G,H) ->
 %code.
#+END_EXAMPLE

Later used in the code as

#+BEGIN_EXAMPLE
 set_up_user_connection(R#rec.a,
                        BlackListed,
                        Codec,
                        UserList,
                        true,
                        ?T1, 
                        DcData,
                        OARec)

#+END_EXAMPLE

** Cause of anti-pattern

I imagine the thinking goes something like this: "There was a function there, doing what I wanted, almost. 
So, I'll just tag along this extra data, and add another case/if clause." - this is again an example 
of 'Shotgun Surgery' ({{{REFAC()}}}).

** Solution

Data that has coherence and used as one is better to pass as one, this way you do not need
to change the arity of ALL functions which the data has to pass through. The next time this 
package is given another unit of data, you can save yourself and everyone else the 
time of changing all the function calls where the new explicit argument is needed. 
In object orientation there is a refactoring to deal with this, called 'Introduce Parameter Object' ({{{REFAC()}}}).

There are two good ways to do this, we can use records, or proplists.

*** The record approach

Define a private record with an intention-revealing name

#+BEGIN_EXAMPLE
-record(#user_conection_conf,
         {user_name,
          blacklisted_contacts,
          negotiated_codec,
          friends_list,
          has_lte_support,
          connection_side,
          global_dcdata,
          global_oarec}).
#+END_EXAMPLE

*** The proplist approach

An alternative approach is to pass on a proplist, thus adding the intent
for each argument explicitly in the Key part of the KV pair.

#+BEGIN_EXAMPLE
 [{user_name,R#rec.a},
  {blacklisted_contacts,BlackListed},
  {negotiated_codec, Codec},
  {friends_list, UserList},
  {has_lte_support,true},
  {connection_side,?T1},
  {global_dcdata,DcData},
  {global_oarec,ObaRec}
 ].
#+END_EXAMPLE

This way we avoid the same problem of having to add extra arguments to all functions.
Of course, the difference here is that access time will be slower in comparison to using a record.
On the upside, you can change the amount of parameters passed internally without disturbing records
in datbases during upgrade.
\newpage

* Excessive feature disclosure (EFD)

Excessive feature disclosure is a mix of the bad code smells 'Long Method' ({{{REFAC()}}}), 
'Shotgun Surgery' ({{{REFAC()}}}), 'Inappropriate Intimacy' ({{{REFAC()}}}) and 'Mixing 
Levels Of Abstraction' ({{{CLEANCODE()}}}).

Manifested through huge functions with exuberant amounts of case/if statements, 
predicates and equal amounts of incoherent code manipulating small parts of data.
Sometimes the mysterious blocks are commented, and sometimes not. An analogy of such a 
function is a recipe which varies wildly paragraph by paragraph, mentioning 2 spoons of sugar, 
then delving into specific Amperes in stove conduits. Only to end with mind boggling thermodynamics
on the topic of hot-air swirl patterns and the effect on crust forming.

In essence, feature specific mainpulations are visible at the same level of abstraction
as more generic code. It is not abstracted or hidden where necessary.

** Example of EFD
   
#+BEGIN_EXAMPLE
process_message(Message,C) ->
 ok = ensure_there_is_a_free_channel(C),
 ok = ensure_the_db_has_a_free_slot(C),
 %% message reversal feature
 Msg1 = case C#conf.reversal_turned_on of
          true -> lists:reverse(Message);
          false -> Message
        end,
 %% message truncation feature
 Msg2 = case C#conf.truncation_turned_on of
          true -> element(1,
                     lists:foldr(
                       fun(_,{Acc,1}) -> {Acc,0};
                          (C,{Acc,0}) -> {[C|Acc],1}
                       end,
                       {[],0},
                       Msg1));
          false -> Msg1
         end,
  send_message_to_recipient(Msg2),
  db:store_msg_with_ref(Msg2,C).
#+END_EXAMPLE

** Cause of anti-pattern

The mindset of getting it done quick and dirty is the basis for the emergence of this pattern. Small increments of 
code with precise predicate-pinballing will trigger the wanted code, while leaving the 
rest untouched. Locally it is okay, but taking a step back - it becomes obvious that the surrounding context of 
the increment is polluted. Reading such functions top top down is a true feat of mental parcour where each block 
has no relation to the previous, and the whole thing makes no direct sense.
 
** Solution

A general good guideline from Software Craftsmanship is, when you feel something warants a comment to truly 
express your intent: put it in a function. In object orientation we find the refactoring 'Extract Method' ({{{REFAC()}}})
for just this purpose. Put the code into a function, and give it a name which discloses the intent.

#+BEGIN_EXAMPLE
process_message(Message,C) ->
 ok = ensure_there_is_a_free_channel(C),
 ok = ensure_the_db_has_a_free_slot(C),
 Msg1 = feature:possibly_reverse(Message,C),
 Msg2 = feature:possibly_truncate(Msg1,C),
 send_message_to_recipient(Msg2),
 db:store_msg_with_ref(Msg2,C).
#+END_EXAMPLE

Then we can try to reduce the amount of variable bindings as well

#+BEGIN_EXAMPLE
process_message(OldMessage,C) ->
 ok = ensure_there_is_a_free_channel(C),
 ok = ensure_the_db_has_a_free_slot(C),
 SS = [OldMessage,C],
 NewMsg = seq([fun feature:possibly_reverse/1,
               fun feature:possibly_truncate/1
              ],SS),
 send_message_to_recipient(NewMsg),
 db:store_msg_with_ref(Msg2,C).
#+END_EXAMPLE

Adding yet two, three, or five new features that each one manipulate the message is just new hooks into the 
sequencing. However, the main point is the abstraction that now makes it easy to understand the main flow.

\newpage

* Mixing Pure and Side Effecting Code (MPSEC)
Mixing functionally pure and side effecting code is a common
and unfortunate antipattern as it makes the code hard to test
and difficult to abstract.

#+BEGIN_EXAMPLE
  _______________
 |.......o....o..|
 |..oo...o..o....|
 |.......o....o..|
 |.....o......o..|
 |..o.o..ooo.....|
 |....o.o....o.o.|
  ---------------

  o = impurity    
  . = pure code
#+END_EXAMPLE

Impure functions are usually related to reading/writing configuration data and 
sending/receiving messages. It is not uncommon for such impurity to cluster in areas
related to gate logic (testing for certain conditions to hold, such as input validation.

It is better to localise side-effecting (impure) code to a few places in the code, 
or to push the impure code out to the fringes of the system.

** Cause of anti-pattern

Lack of TDD will allow hard to test code to grow in your repository.

** Solution

Develop using TDD. Doing TDD will force you to decompose single operations as
functions handling one part of the functionality: automatically separating the
impurity from the purity.

The outcome from such a design is a collection of pure libraries, which are utilized by a 
few impure modules - essentially 'orchestrating' the flow. All of the pure libraries can be Unit tested 
easily, while the few orchestrators can be tested using Component Tests. Mocking will also be easier as 
the code is well contained in pure library functions.

*** A system where impurity is pushed towards the fringes

#+BEGIN_EXAMPLE
  _______________
 |             |I|
 |  SYSTEM     |M|
 |  COMPOSED   |P|
 |  OF PURE    |U|
 |  FUNCTIONS  |R|
 |             |E|
 |_____________|_|

   ^            ^
   |            |
   |             \ More difficult to test
   |              
    \ Easy to Unit Test = Write with TDD

#+END_EXAMPLE

*** A system where impurity is clustered into a few points

#+BEGIN_EXAMPLE
  _______________
 |...............|
 |..oo...........|
 |..oo.......oo..|
 |...........oo..|
 |...............|
 |...............|
  ---------------

  o = impurity    
  . = pure code
#+END_EXAMPLE

\newpage
* Implicit Branch Condition Encoded In Primitives (IBCEIP)

Implicit Branch Conditin Encoded In Primitives is coupled to the bad code smell Primitive Obsession where
primitive data types are used to represent domain ideas ({{{CLEANCODE()}}}). The difference is that in 
IBCEIP, the branching reason is hidden and not made explicit with the help of the language.

This makes for very hard to read code that can not be understood unless you have the full context
and history of the program being developed in order to understand why certain primitives are patternmatched.

** Example of IBCEIP

Consider the following code that handles session restore on a system failure, in this particular case we will 
look at how the different backup_session function clauses are chosen based on the user being behind nat or not.

#+BEGIN_EXAMPLE
backup_session(#user{ctd=#conn{ip=A,port=B},
                     last_msg=[#msg{trp=#conn{orig_ip_text=C}}|_]}) 
                     when A =/= C ->
  %% This is NAT because the last seen message from the user has an 
  %% originates ip text from another IP address than the user connected from. 
  %% 
   ....
backup_session(User) ->
   %% normal case
   ....
#+END_EXAMPLE

Notice how the comment is used to tell us why this is a special case, this is a typical example of how
comments are a deodorant - hiding a bad code smell. But we know that comments will rot and start to lie
about reality when people update the code but does not update the comments.

** Solution

Add a function that takes a #user\{\} record and returns an appropriate representation of the branch condition.
Use this value instead when patternmatching, put the value in the record, or pass it to the backup_session/1
function, making it take 2 arguments instead.

#+BEGIN_EXAMPLE
determine_connectivity_mode(User) ->
   #user{ctd=#conn{ip=A},last_msg=[#msg{trp=#conn{orig_ip_text=C}}|_]}) = User,
   case A == C of  
    true  -> normal;
    false -> behind_nat.

backup_session(User,behind_nat) ->
   ...;
backup_session(User,normal) ->
   ....
#+END_EXAMPLE

Notice how the backup_session/2 code conveys intent in a much better way.
The determine_connectivity_mode/1 function is also very easy to test and would be a perfect
candidate function for TDD.

\newpage
* Not an Antipattern - (Seq)uence
 
In the chapter Variable Binding ad Nauseum, we touched on the subject of seq style programming.
This chapter explores the seq concept further and lays the foundation for the theory needed when analysing this
deeper into the rec style (a cousin of seq that allows for an elegant recursive programming style).

** Seq
Seq takes a list of functions, some initial data

#+BEGIN_EXAMPLE
 Seq :: [F] x D -> D
#+END_EXAMPLE

and it folds the functions over the data, effectively applying each and every function on the input 
from the previous function; for the initial function this means the initial data, as there is no other 
function that can be called to produce the data.

#+BEGIN_EXAMPLE
 D_0 = Input data
 D_1 = f_1(D_0)
 D_2 = f_2(D_1)
 ...           
 D_n = f_n(D_(n-1))
#+END_EXAMPLE

*** Why Seq-style programming

Seq style programming is nice as it allows us to give longer function names without compromising clarity - this due to the
line-length being used fully for a function name and making all variable bindings and arguments implicit.
We can thus rewrite code from this unhelpfull format

#+BEGIN_EXAMPLE
send_msg(Msg) ->
  case build_pkt(Msg) of
    {ok,Bin} ->
       tranceiver:send(Bin)
    Err ->
       Err
  end.

build_pkt(Msg) ->
  case detrm_routing(Msg) of
    {ok, RoutingData} ->
       build_pkt(Msg, RoutingData);
    Err ->
        Err
  end.

build_pkt(Msg, RoutingData) ->
  case build_hdrs(Msg, RoutingData) of
     {ok, Hdrs} ->
        build_pkt(Msg, RoutingData, Hdrs);
     Err ->
        Err
  end.
.... 
#+END_EXAMPLE

into a collapsed format, where each line is fully dedicated to showing the function names, which are intent-bearing.
This new format would then look like this instead

#+BEGIN_EXAMPLE
send_msg(Msg) ->
  seq([fun create_packet_skeleton/1,
       fun determine_routing_data/1,
       fun determine_via_headers/1,
       fun determine_contact_header/1,
       fun set_via_headers/1,
       fun set_contact_headers/1,
       fun build_binary/1,
       fun send_binary_via_tranceiver/1,
       get_configuration()).
#+END_EXAMPLE

Not only do we observe this benefit, we also notice that collapsing the nesting increases maintainability 
and allows for a programming style where the underlying, hidden logic becomes visible and available.
See the example code in the end of the VBAN chapter as an example.
\newpage
*** Function families

Every function $f_i \in$ [F] which is passed to Seq can be classified as beloning to one of three function families $f_p, f_m or f_n$.

**** $f_p$ - Pure family 
This is a functionally pure function, the return value is used to update the input data to Seq on which we fold our
functions. The only reason for using this function is for the pure calculation done with the use of the input data that
is sent to it.

#+BEGIN_EXAMPLE
f(X) ->
   X + 1.
#+END_EXAMPLE

**** $f_m$ - Mixed family
This is an functionally impure family of functions, meaning that they have side effects, but the returned 
value is still of interest for the next function in seq. As this has a side-effect, we can think of this family
of functions as updating an implicit global state $\Omega$. 

#+BEGIN_EXAMPLE
f(X) ->
  a ! X,
  X + 1.
#+END_EXAMPLE

**** $f_n$ - Nullifier family
This is a family of functions which has an unused return value, meaning we do not care about the return value of the
function. The function is only invoked due to the side effects of the function. Thus, the result is nullified in the 
eyes of the next function to be invoked in the seq chain.

#+BEGIN_EXAMPLE
f(X) ->
  a ! X.
#+END_EXAMPLE

\newpage
*** Function class family diagram 

All families relate to the Seq input data D and the global state Omega in some way.
In the diagram below, an arrow from D -> to a family means that this family uses the data D for its calculation.
An arrow from a family $f_m$ -> to either D or $\Omega$ means that this family has a return value that updates the 
data in D or $\Omega$.

#+BEGIN_EXAMPLE

   D <--------\     Omega
   |          |       ^
   |--> f_p --|       |
   |          |       |
   |--> f_m --/-------|
   |                  |
   \--> f_n-----------/

#+END_EXAMPLE

*** The problem of passing and updating data

We know that all functions $f_i \in$ [F] passed to Seq will most likely not operate on the same data.
The naive way is to pass one large data structure to each function $f_i$, thus creating a uniform set of functions
with arity 1, where each one receives and returns the same data structure, but with some minor changes.
If we choose such an approach, the functions that are part of $f_p$ and $f_m$ will return an updated version of the data
structure, but the $f_n$ type functions will pass the original data structure through - effectively $f_n$ becomes identity
to the data structure.

#+BEGIN_EXAMPLE
seq([fun f_p/1,
     fun f_m/1,
     fun f_n/1
    ], Data).

f_p(D#d{b=B,d=D}) ->
  D#d{z=B+D}.

f_m(D#d{e=E,f=F,k=K}) ->
  a ! {E,F,K},
  D#d{x = E*F - K}.

f_n(D#d{f=F}) ->
  a ! F,
  D.
#+END_EXAMPLE

However, this is not ideal as it programmatically implies that all data is needed for each function, and also makes 
tracing intractable due to large data sets being printed onto the screen. This also causes a deeper problem: artificial
dependency through coupling. In reality, we know that the functions need a coherent subset of the data, 
but we do not really care how this data is passed to our calculating functions.

What if we could write the functions in this way instead?

#+BEGIN_EXAMPLE
seq([fun f_p/1,
     fun f_m/1,
     fun f_n/1
    ], Data).

f_p([B,D]) ->
  B+D.

f_m([E,F,K]) ->
  a ! {E,F,K},
  E*F - K.

f_n([F]) ->
  a ! F.
#+END_EXAMPLE

They certainly look cleaner, but how shall we now handle the data passing of the right data and the data updating of the 
right data in D? This is where we need function specific get and update functions. The explicit extraction and updating of
values from/to the record #d\{\\} must now be handled by external functions instead.

Imagine the following functions $get_{f_i}$ and $update_{f_i}$ which does the needed data extraction and updating for the
function $f_i$. For the previous example, the functions $get_{f_p}$ and $update_{f_p}$ would look as follows.

#+BEGIN_EXAMPLE
get(#d{b=B,d=D}) -> [B,D].
update(Z,D) -> D#d{z=Z}.
#+END_EXAMPLE

for the nullifier, the same functions $get_{f_n}$ and $update_{f_n}$ would look as follows.

#+BEGIN_EXAMPLE
get(#d{b=F}) -> [F].
update(_,D) -> D.
#+END_EXAMPLE

we have now decoupled the data structure which is convenient to use while passing data to many functions from how
we pass data to one function. This is a big destinction. get and update are cousins to the lens ({{{LENSES()}}}) 
concept from Haskell which facilitates access and update of data structures, allowing the computations to remain unaware
of how the data got there, or where it is going.

#+BEGIN_EXAMPLE
 data D
      --------------------
     |  ____         _    |
     | |    |       |_|   |
     | |____|        ^    |
     |__|____________|____|
	|            |
	|get         |update
	|            | 
	v            |
	\____f_p ____/
#+END_EXAMPLE

Now that we have this model for decoupling calculators from the way we carry data, we can take the first stab at 
utilizing it, we obviously need to modify seq so that it not only folds the functions, but also utilizes the right
get and update functions. To make matters simple, we start by supplying a 3-tuple instead of just the calculator 
function. As we know how the get and update functions look like, this only shows the modified seq function.

#+BEGIN_EXAMPLE
seq([{fun f_p/1, fun get_f_p/1, fun update_f_p/1},
     {fun f_m/1, fun get_f_m/1, fun update_f_m/1},
     {fun f_n/1, fun get_f_n/1, fun update_f_n/1},
    ], Data).

seq([],Data) -> Data;
seq([{F, Get, Update}|T],Data) ->
  seq(T,Update(F(Get(Data)),Data)).
#+END_EXAMPLE

This is syntactically cumbersome and counteracts the clarity that was gained when using the seq style to begin with. 
As we pass a 3-tuple to seq in place of the calculator functions, we can now generate this structure from a function call
instead. Thus we can now try to collapse nested structures by using the proposed skeleton of the better seq style.

#+BEGIN_EXAMPLE
seq([f_p(), 
     f_m(),
     f_n()], Data).

seq([],Data) -> Data;
seq([{F, Get, Update}|T],Data) ->
  seq(T,Update(F(Get(Data)),Data)).

f_p() ->
 {fun f_p/1, 
  fun(D#d{b=B,d=D})-> [B,D] end,
  fun(Z,D) -> D#d{z=Z} end}.

f_m() ->
  {fun f_m/1, 
   fun(D#d{e=E,f=F,k=K}) -> [E,F,K] end,
   fun(X,D) -> D#d{x=X} end}.

f_n() ->
  {fun f_n/1, 
   fun(D#d{f=F}) -> [F] end,
   fun(D) -> D end}.
#+END_EXAMPLE

The most atractive gain is that the computations are argument-object agnostic and only cares for calculations 
using the data which is absolutely essential. We can exchang the data-carrying type from record, to list,
to whatever, and we only need to make modifications in the $get_{f_i}$ and $update_{f_i}$ functions and the 
calculations are kept intact. We have now made the method with which we make data cohesive - totally transparent
to our calculations and removed all traces of coupling from them.
\newpage
*** Short circuit Seq style

We can accomodate error handling and short-circuit seq style programming, bringing us close to Haskell's
Maybe monad by requiring all composite functions $f_i \in$ [F] to return either \{ok,Result\} or \{error,Reason\}.
We can still utilize the specific $get_{f_i}/update_{f_i}$ functions to work with the data. The Term in \{error,Term\} 
is the error reason we want to propagate unto the rest of the system.

We now define short circuit Seq which can handle error conditions. 

#+BEGIN_EXAMPLE
seq([],Data) -> 
   Data;
seq([{F,G,U}|Fs],Data) ->
 case F(G(Data)) of
   {ok,Result} ->
      seq(Fs,U(Result,Data));
   Error ->
      Error
 end.
#+END_EXAMPLE

This definition shows that the sequence ends when either there are no more functions to apply (like before),
or when there is an error. This is preferrable to try/catch programming that will potentially hide more serious errors,
makes tracing hard, and also incurs a slight performance penalty on run-time. Instead, write proper functions that
either return \{error,Reason\} or \{ok,Result\}.

Consider the following code for trying to perform a transaction between two accounts from different banks, as 
you can see, there are plenty of things that can 'fail' (cause the transaction to abort).

#+BEGIN_EXAMPLE
private_transaction({FromBank,FromAccount}=From,
                    {ToBank,ToAccount}=To,
                    {Amount,Currency}=Payment) ->
  try
      ok = is_amount_valid(Amount),
      {ok,FromBankID} = get_bank_id(FromBank),
      {ok,ToBankID} = get_bank_id(ToBank),     
      is_valid(get_prefix(FromAccount),FromBankID),
      is_valid(get_prefix(ToAccount),ToBankID),
      ok = send_request_to_bank(debit,FromBankID,FromAccount,Amount,Currency),      
      ok = send_request_to_bank(credit,ToBankID,ToAccount,Amount,Currency),
      transaction_log:record(FromBank,ToBank,Payment)
  catch
      _:_ ->
        transaction_log:error("Transaction not performed",[From,To,Payment])
  end.       
#+END_EXAMPLE

Now, we would instead like to write this using a short-circuit seq programming style that facilitates maintainbility
and reading of the source code.

#+BEGIN_EXAMPLE
private_transaction(Payment_data) ->
  seq([fun verify_that_amount_is_valid/1,
       fun verify_that_from_bank_exists/1,
       fun verify_that_to_bank_exists/1,
       fun verify_that_from_account_exists/1,
       fun verify_that_to_account_exists/1,
       fun verify_that_sending_bank_accepts_debit/1,
       fun verify_that_receiving_bank_accepts_credit/1,
       fun log_transaction/1
      ],Payment_data).
#+END_EXAMPLE

The implicit guarantee here is that every function returns {ok,Data} or {error,Reason} as stated
previously. We can also test every function $f_i \in$ [F] and compose our system of pure and well-behaved
functions.
\newpage
* Not an Antipattern - (Rec)ursive

Seq is as the name describes sequential, and not intended for recursive computations.
For this, we introduce rec. Rec takes a list of functions, a boolean predicate P $\in f_p$ and
some initial data.

** Rec 
#+BEGIN_EXAMPLE
Rec :: [F] x P x D -> D
#+END_EXAMPLE

we can model rec with the use of seq, the transformation will be shown in steps.
First, lets start by drawing the call tree of rec, it is reasonable that the predicate
is a stop-condition which is always evaluated first. If the result is T, the recursion
ends, returning the data. If the result is F, the recursion continues.

#+BEGIN_EXAMPLE
   P D <---------------------
    |  \                     \
   T|   \F                   |
    V    V                  /
   D      D' = f_1...f_n D--
#+END_EXAMPLE

Now, it is trivial to realize that the call sequence $f_1$ ... $f_n$ on D 
can be replaced with seq in an elegant manner

#+BEGIN_EXAMPLE
   P D <----------
    |  \           \
   T|   \F          |
    V    V         /
   D      seq F D -
#+END_EXAMPLE

we can now therefore name this recursive structure rec, using Haskell notation 
rec would be written in the following manner, assuming seq is already defined.

#+BEGIN_EXAMPLE
rec f p d  | p d  = d
           | else = rec f p (seq f d)
#+END_EXAMPLE

Notice that rec never needs to observe the functions $f_i \in$ [F]. Of course, 
it shall be said that all $f_i \in$ [F] can in turn utilize both rec and sec style
programming without problems. 

*** Echo Server Example
But first we shall look at how to utilize a rec style
recursion, given a semi-interesting problem like a small reverse-echo server handling one
connection at a time - until someone sends the keyword 'die'

#+BEGIN_EXAMPLE
echo_server() ->
  {ok,Sock} = gen_tcp:listen(5055,[{active,false}]),
  echo(Sock).

echo(Sock) ->
  {ok,ASock} = gen_tcp:accept(Sock),
  {ok,Bin} = gen_tcp:recv(ASock,0),
  Msg = binary_to_list(Bin),
  gen_tcp:send(ASock,lists:reverse(Msg)),
  gen_tcp:close(ASock),
  case Msg of
    "die" ->
         ok;
     _ ->  
         echo(Sock)
  end.
#+END_EXAMPLE

We will now rewrite this little server using rec-style programming with composite seq
functions. It is very simple to realize that the end condition is that we recieved "die".
Thus, received == "die" will be the predicate.

#+BEGIN_EXAMPLE
stop_if_received_die(S) -> 
   S#state.received == "die".
#+END_EXAMPLE

Next we break the flow into it's component parts, we receive a message,
we reverse it, send it back, and close the connection.

#+BEGIN_EXAMPLE
receive_message_from_client(S) ->
  {ok,ASock} = gen_tcp:accept(S#state.sock),
  {ok,Binary} = gen_tcp:recv(ASock,0),
  S#state{accept_socket = ASock, received = binary_to_list(Binary)}.

reverse_message(S) ->
  S#state{msg = lists:reverse(S#state.received)}.

send_back_message(S) ->
  gen_tcp:send(S#state.accept_socket,S#state.msg),
  S.

close_the_connection(S) ->
  gen_tcp:close(S#state.accept_socket),
  S.
#+END_EXAMPLE

we can now write our echo sever using rec (which internally utilizes seq for the sequencing of the component steps).

#+BEGIN_EXAMPLE
echo_server() ->
  {ok,Sock} = gen_tcp:listen(5055,[{active,false}]),
  Data = #state{sock=Sock},
  rec([fun receive_message_from_client/1,
       fun reverse_message/1,
       fun send_back_message/1,
       fun close_the_connection/1],
       fun stop_if_received_die/1
       Data).

stop_if_received_die(S) -> 
   S#state.received == "die".

receive_message_from_client(S) ->
  {ok,ASock} = gen_tcp:accept(S#state.sock),
  {ok,Binary} = gen_tcp:recv(ASock,0),
  S#state{accept_socket = ASock, received = binary_to_list(Binary)}.

reverse_message(S) ->
  S#state{msg = lists:reverse(S#state.received)}.

send_back_message(S) ->
  gen_tcp:send(S#state.accept_socket,S#state.msg),
  S.

close_the_connection(S) ->
  gen_tcp:close(S#state.accept_socket),
  S.
#+END_EXAMPLE

*** Simplifies extendability

The point here is that we can very quickly get a very good understanding of the echo_servers 
inner workings at a glance. Only by reading the names of the functions in one quick succession. 
We can also easily Unit Test each seq function which the rec will utilize. Granted, it looks like 
we have a little more code, but it is very easy to extend, just add another function in the appropriate place 
in the call chain. It is also easy to isolate and correct bugs, each component function is short and 
easily understood.

*** Simplifies accelerated comprehension

One of the main benefits is that rec/seq style allows us to cognitively operate on an more abstract
level when comprehending flow, and delve into details when it is necessary. This is in stark contrast
to 'normal' non-rec/seq style where you need to pass over details in order to comprehend general flow.

As large legacy systems accumulate more and more logic, it is of great interest to have a style
and design that facilitates quick comprehension without forcing the developers to understand small
insignificant details to get the whole picture. When it comes to quickly understanding flow and even 
more importantly the 'intent' (the why), I am sure you would rather read this

#+BEGIN_EXAMPLE
  [fun receive_message_from_client/1,
   fun reverse_message/1,
   fun send_back_message/1,
   fun close_the_connection/1]
#+END_EXAMPLE

than reading this

#+BEGIN_EXAMPLE
  {ok,ASock} = gen_tcp:accept(Sock),
  {ok,Bin} = gen_tcp:recv(ASock,0),
  Msg = binary_to_list(Bin),
  gen_tcp:send(ASock,lists:reverse(Msg)),
  gen_tcp:close(ASock),
#+END_EXAMPLE

when trying to understand a general flow in a new module you have never seen.
Another point worth noting is that this echo server is quite trivial, so often 
the gritty details will likely be worse than this.
